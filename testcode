// ok le 3juin 2018
// 2 moteurs fonctionnent en tandem
// le 4/6 test reverse + ultrason sur pin D5


// oled SDA SCL     sur SDA = A4   SCL = A5
#include "U8glib.h"
#include <Wire.h>
U8GLIB_SSD1306_128X64 u8g(U8G_I2C_OPT_NONE|U8G_I2C_OPT_DEV_0);

#define enA 11
#define in1 12
#define in2 13
#define in3 8
#define in4 9
#define enB 10

// L298 Wiring
#define In1   12                     // INA motor pin
#define In2   13                     // INB motor pin 
#define enA   11                     // PWM motor pin
#define In3   8                      // INA motor pin
#define In4   9                      // INB motor pin 
#define enB   10                     // PWM motor pin
#define encodPinA1      2            // encoder A pin
#define encodPinB1      3            // encoder B pin

#define LOOPTIME        100          // PID loop time
#define NUMREADINGS     10           // samples for Amp average

int readings[NUMREADINGS];
unsigned long lastMilli = 0;         // loop timing 
unsigned long lastMilliPrint = 0;    // loop timing

// reglage de la vitesse par défaut
int speed_req = 15;                  // speed (Set Point)
int speed_reqA = speed_req;
int speed_reqB = speed_req;

int speed_actA = 0;                   // speed (actual value)
int speed_actB = 0;                   // speed (actual value)
int PWM_valA = 0;                     // (25% = 64; 50% = 127; 75% = 191; 100% = 255)
int PWM_valB = 0;                     // (25% = 64; 50% = 127; 75% = 191; 100% = 255)
int countA = 0;
int countB = 0;
int countTotalA = 0;
int countTotalB = 0;

int turn = 0;                         // 0 = straight   1 = Right   2= left

volatile long count = 0;                        // rev counter
float Kp =   .4;                                // PID proportional control Gain
float Kd =    1;                                // PID Derivitave control gain

void setup() {
 analogReference(EXTERNAL);                            // Current external ref is 3.3V
 Serial.begin(115200);
 
 pinMode(In1, OUTPUT);
 pinMode(In2, OUTPUT);
 pinMode(enA, OUTPUT);

 pinMode(In3, OUTPUT);
 pinMode(In4, OUTPUT);
 pinMode(enB, OUTPUT);
 
 pinMode(encodPinA1, INPUT); 
 pinMode(encodPinB1, INPUT);

 //configure pin5 as an input and enable the internal pull-up resistor
 pinMode(5, INPUT_PULLUP);
 
 digitalWrite(encodPinA1, HIGH);                      // turn on pullup resistor
 digitalWrite(encodPinB1, HIGH);
 attachInterrupt(0, encoderA, FALLING);  // appel interruption 0 sur D2
 attachInterrupt(1, encoderB, FALLING);  // appel interruption 1 sur D3
 
 for(int i=0; i<NUMREADINGS; i++)   readings[i] = 0;  // initialize readings to 0

 analogWrite(enA, PWM_valA);
 digitalWrite(in1, LOW);
 digitalWrite(in2, HIGH);
}

void loop() {

int sensorVal = digitalRead(5);    //read the value of D5 and put it in sensorVal

//getParam();   // check keyboard  // lecture clavier
 
 if((millis()-lastMilli) >= LOOPTIME)   {                        // enter tmed loop
    lastMilli = millis();

    getMotorDataA();                                             // calculate speed,
    getMotorDataB();                                             // calculate speed,
    PWM_valA= updatePidA(PWM_valA, speed_reqA, speed_actA);      // compute PWM value
    PWM_valB= updatePidB(PWM_valB, speed_reqB, speed_actB);      // compute PWM value
    MotorA_Fwd(PWM_valA);
    MotorB_Fwd(PWM_valB);

//**************************
if (sensorVal == HIGH) {     // test entrée D5
      MotorA_Fwd(PWM_valA);
      MotorB_Rev(PWM_valB);
    }
//***************************


//*********************************************
/* alternative compteur de roue

    if ((countTotalA+countTotalB) > 2000 && (countTotalA+countTotalB) < 2500) {
      MotorA_Fwd(PWM_valA);
      MotorB_Rev(PWM_valB);
    }

    if ((countTotalA+countTotalB) > 2500) {
      countTotalA=0;
      countTotalB=0;
    }
*/


} // end of loop
//***********************************




// display data
 
 //***************************************
//affiche des données sur écran oled   //
u8g.firstPage();  
do {
    draw();
   } while( u8g.nextPage() );
// **************************************
 
 printMotorInfo();                                                           // display data
 
} // end of loop




// *************************************
// *** calculate speed motor A and B ***
// *************************************
void getMotorDataA()  {                                            // calculate speed motor A
static long countAntA = 0;                                          // last count
 speed_actA = ((countA - countAntA)*(60*(1000/LOOPTIME)))/(22*34);  // 16 pulses X 29 gear ratio = 464 counts per output shaft rev
 countAntA = countA;
}

void getMotorDataB()  {                                            // calculate speed motor B
static long countAntB = 0;                                         // last count
 speed_actB = ((countB - countAntB)*(60*(1000/LOOPTIME)))/(22*34);  // 16 pulses X 29 gear ratio = 464 counts per output shaft rev
 countAntB = countB;  
}





// *************************************
// *** Compute PID for motor A and B ***
// *************************************
int updatePidA(int command, int targetValue, int currentValueA)   {             // compute PWM value
float pidTermA = 0;                                                            // PID correction
int errorA=0;                                  
static int last_errorA=0;                             
 errorA = abs(targetValue) - abs(currentValueA); 
 pidTermA = (Kp * errorA) + (Kd * (errorA - last_errorA));
 last_errorA = errorA;
 return constrain(command + int(pidTermA), 0, 255);
}

int updatePidB(int command, int targetValue, int currentValueB)   {             // compute PWM value
float pidTermB = 0;                                                     // PID correction
int errorB=0;
static int last_errorB=0;
 errorB = abs(targetValue) - abs(currentValueB); 
 pidTermB = (Kp * errorB) + (Kd * (errorB - last_errorB));
 last_errorB = errorB;
 return constrain(command + int(pidTermB), 0, 255);
}



void printMotorInfo()  {                                                      // display data
 if((millis()-lastMilliPrint) >= 500)   {                     
   lastMilliPrint = millis();
   Serial.print("SP:");             Serial.print(speed_req);
   Serial.print(" SPA:");           Serial.print(speed_reqA);
   Serial.print(" SPB:");           Serial.print(speed_reqB);
   
   Serial.print("    RPM A:");        Serial.print(speed_actA);
   Serial.print("  PWM A:");          Serial.print(PWM_valA);
   
   Serial.print("      RPM B:");      Serial.print(speed_actB);
   Serial.print("  PWM B:");          Serial.print(PWM_valB);

   Serial.print("    countTotal A:");        Serial.print(countTotalA);
   Serial.print("  countTotal B:");          Serial.println(countTotalB);


 }
}

//***********************
//*** interruption 0 ****
//***********************
void encoderA()  {   // pulse and direction, direct port reading to save cycles
    countA++;
    countTotalA++;
}

//***********************
//*** interruption 1 ****
//***********************
void encoderB()  {   // pulse and direction, direct port reading to save cycles
    countB++;
    countTotalB++;
}





int getParam()  {
char param, cmd;
 if(!Serial.available())    return 0;
 delay(10);                  
 param = Serial.read();                              // get parameter byte
 if(!Serial.available())    return 0;
 cmd = Serial.read();                                // get command byte
 Serial.flush();
 switch (param) {
   case 'v':        // adjust speed
     if(cmd=='+')  {
       speed_req += 5;
        speed_reqA = speed_req;
        speed_reqB = speed_req;
       if(speed_req>400)   speed_req=400;
     }
     if(cmd=='-')    {
       speed_req -= 5;
        speed_reqA = speed_req;
        speed_reqB = speed_req;       
       if(speed_req<0)   speed_req=0;
     }
     break;
     
   case 't':       // adjust direction
     if(cmd=='r'){
      speed_reqA -= 5;                     // turn set to 1 => turn right
       
     }
     if(cmd=='l')   {
      speed_reqB-= 5;                      // turn set to 1 => turn right
     }
     break;
   case 'o':                               // user should type "oo"
     //digitalWrite(in1, LOW);
     //digitalWrite(in2, LOW);
     speed_req = 0;
     break;
   default: 
     Serial.println("???");
   }
}

int digital_smooth(int value, int *data_array)  {    // remove signal noise
static int ndx=0;                                                         
static int count=0;                          
static int total=0;                          
 total -= data_array[ndx];               
 data_array[ndx] = value;                
 total += data_array[ndx];               
 ndx = (ndx+1) % NUMREADINGS;                                
 if(count < NUMREADINGS)      count++;
 return total/count;
}




// ***************************************
// controle des moteurs AVANT et ARRIERE
// ***************************************

void MotorA_Fwd(int a) // Motor A forward
{
analogWrite (enA,a); // Contrôle de vitesse en PWM
digitalWrite(in1, HIGH);
digitalWrite(in2, LOW);
}

void MotorA_Rev(int a) // Motor A forward
{
analogWrite (enA,a); // Contrôle de vitesse en PWM
digitalWrite(in1, LOW);
digitalWrite(in2, HIGH);
}

void MotorB_Fwd(int a) // Motor A forward
{
analogWrite (enB,a); // Contrôle de vitesse en PWM
digitalWrite(in3, LOW);
digitalWrite(in4, HIGH);
}

void MotorB_Rev(int a) // Motor A forward
{
analogWrite (enB,a); // Contrôle de vitesse en PWM
digitalWrite(in3, HIGH);
digitalWrite(in4, LOW);
}


// ******************
// affichage oled
// ******************

void draw(void) {
u8g.setFont(u8g_font_unifont);

u8g.setPrintPos(2, 15);         u8g.print("Data/ Rpm / Pwm");
u8g.setPrintPos(2, 30);         u8g.print("Rq   :");
u8g.setPrintPos(2, 45);         u8g.print("MotA :");
u8g.setPrintPos(2, 60);         u8g.print("MotB :");
  
u8g.setPrintPos(52, 30);  u8g.print(speed_req); u8g.setPrintPos(92, 30);  u8g.print("---");
u8g.setPrintPos(52, 45);  u8g.print(speed_actA);   u8g.setPrintPos(92, 45);  u8g.print(PWM_valA);
u8g.setPrintPos(52, 60);  u8g.print(speed_actB);   u8g.setPrintPos(92, 60);  u8g.print(PWM_valB);

}




 
